# UHDI+ â€” Unified Health Data Integrator Plus
# Google Colab Ready â€” Modular, Extensible ML on Unified Healthcare Data

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import (
    classification_report,
    confusion_matrix,
    roc_auc_score,
    roc_curve
)

# Optional: Uncomment to use XGBoost
# !pip install xgboost
# from xgboost import XGBClassifier

# 1. Set seed and simulation size
np.random.seed(42)
N_PATIENTS = 2000

# 2. Generate EHR Data
def simulate_ehr_data(n):
    return pd.DataFrame({
        'patient_id': np.arange(n),
        'age': np.random.randint(20, 90, n),
        'num_prior_admissions': np.random.poisson(1.5, n),
        'num_comorbidities': np.random.randint(0, 5, n),
        'discharge_disposition': np.random.choice(['home', 'rehab', 'death'], n)
    })

# 3. Simulate Wearable Time Series Data
def simulate_wearable_data(n, days=7):
    return pd.DataFrame({
        'patient_id': np.repeat(np.arange(n), days),
        'day': list(range(days)) * n,
        'steps': np.random.poisson(lam=5000, size=n*days)
    })

# 4. Aggregate Time-Series to Features
def aggregate_wearable_features(df):
    steps_agg = df.groupby('patient_id')['steps'].agg(['mean', 'std', 'max']).reset_index()
    steps_agg.columns = ['patient_id', 'steps_mean', 'steps_std', 'steps_max']
    return steps_agg

# 5. Generate Target Variable with Realistic Correlation
def generate_target(row):
    score = (
        (row['num_prior_admissions'] > 2) * 1.5 +
        (row['num_comorbidities'] > 2) * 1.3 +
        (row['discharge_disposition'] == 'rehab') * 0.8 +
        (row['steps_mean'] < 4000) * 1.2
    )
    prob = 1 / (1 + np.exp(-score))
    return np.random.rand() < prob

# 6. Preprocess & Merge
def preprocess_data(ehr, wearable):
    wearable_agg = aggregate_wearable_features(wearable)
    data = ehr.merge(wearable_agg, on='patient_id')
    data['readmitted_30days'] = data.apply(generate_target, axis=1).astype(int)
    
    # Encode categorical
    le = LabelEncoder()
    data['discharge_disposition'] = le.fit_transform(data['discharge_disposition'])

    # Define features
    X = data.drop(columns=['patient_id', 'readmitted_30days'])
    y = data['readmitted_30days']

    # Standardize numerical features
    scaler = StandardScaler()
    num_cols = ['age', 'num_prior_admissions', 'num_comorbidities', 
                'steps_mean', 'steps_std', 'steps_max']
    X[num_cols] = scaler.fit_transform(X[num_cols])

    return X, y, data

# 7. Train and Evaluate Model
def train_evaluate_model(X, y):
    X_train, X_test, y_train, y_test = train_test_split(X, y, 
                                                        test_size=0.25, 
                                                        stratify=y,
                                                        random_state=42)
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    y_pred = model.predict(X_test)
    y_proba = model.predict_proba(X_test)[:,1]

    print("âœ… Classification Report:\n", classification_report(y_test, y_pred))
    print("âœ… ROC AUC Score:", round(roc_auc_score(y_test, y_proba), 4))
    print("âœ… Confusion Matrix:\n", confusion_matrix(y_test, y_pred))

    return model, X_train.columns, y_test, y_pred, y_proba

# 8. Plot Feature Importance
def plot_feature_importance(model, features):
    importances = model.feature_importances_
    indices = np.argsort(importances)[::-1]
    
    plt.figure(figsize=(8, 5))
    sns.barplot(x=importances[indices], y=features[indices])
    plt.title("Feature Importance")
    plt.tight_layout()
    plt.show()

# 9. Plot ROC Curve
def plot_roc(y_true, y_score):
    fpr, tpr, _ = roc_curve(y_true, y_score)
    plt.figure(figsize=(6, 4))
    plt.plot(fpr, tpr, label=f'AUC = {roc_auc_score(y_true, y_score):.2f}')
    plt.plot([0, 1], [0, 1], 'k--')
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.title("ROC Curve")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# === Main Pipeline ===
print("ðŸ“Š Simulating healthcare data sources...")
ehr_df = simulate_ehr_data(N_PATIENTS)
wearable_df = simulate_wearable_data(N_PATIENTS)

print("ðŸ”— Merging and preprocessing...")
X, y, full_data = preprocess_data(ehr_df, wearable_df)

print("ðŸš€ Training ML model on unified dataset...")
model, features, y_test, y_pred, y_proba = train_evaluate_model(X, y)

print("ðŸ“ˆ Plotting Feature Importance and ROC...")
plot_feature_importance(model, np.array(features))
plot_roc(y_test, y_proba)
